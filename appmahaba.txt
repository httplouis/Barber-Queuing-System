import tkinter as tk
from tkinter import ttk
import customtkinter as ctk
from datetime import datetime
import time
import requests
import threading
from kafka import KafkaProducer, KafkaConsumer
import json

# Set up Kafka producer for event notifications
producer = KafkaProducer(
    bootstrap_servers=['localhost:9092'],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Set up Kafka consumer to listen for queue updates
consumer = KafkaConsumer(
    'queue-updated',
    bootstrap_servers=['localhost:9092'],
    value_deserializer=lambda m: json.loads(m.decode('utf-8')),
    group_id='client-notification-group',
    auto_offset_reset='latest'  # Only get new messages
)

# Global variables
username_login_entry = None
password_login_entry = None
username_register_entry = None
password_register_entry = None
name_register_entry = None
current_user = None
current_frame = None
frames = {}

# API endpoints
API_BASE_URL = "http://localhost:8000"
AUTH_API_URL = "http://localhost:8001"

# Initialize the app with custom theme
ctk.set_appearance_mode("System")  # Changed from "Dark" to "System" for better appearance
ctk.set_default_color_theme("dark-blue")  # Changed from "blue" to "dark-blue"

app = ctk.CTk()
app.geometry("800x700")  # Made window slightly wider
app.title("✂️ Barber Master Pro")  # Updated app title

# Custom font configurations
TITLE_FONT = ctk.CTkFont(family="Helvetica", size=26, weight="bold")
HEADER_FONT = ctk.CTkFont(family="Helvetica", size=18, weight="bold")
NORMAL_FONT = ctk.CTkFont(family="Helvetica", size=14)
BUTTON_FONT = ctk.CTkFont(family="Helvetica", size=14, weight="bold")

# Sample data (initial state before API connection)
sample_barbers = [
    {"barber_id": "B001", "name": "John Smith"},
    {"barber_id": "B002", "name": "Mike Johnson"},
    {"barber_id": "B003", "name": "Sarah Williams"}
]

sample_services = [
    {"id": "S001", "name": "Classic Haircut", "price": 25},
    {"id": "S002", "name": "Beard Trim", "price": 15},
    {"id": "S004", "name": "Hair Coloring", "price": 50}
]

sample_appointments = []
sample_queue = []
sample_users = [{"username": "test", "password": "test", "name": "Test User", "id": "U001"}]
sample_notifications = [
    {"id": 1, "user_id": "U001", "title": "Welcome!", "message": "Welcome to Barber Master Pro!", "date": "2025-04-28", "read": False},
    {"id": 2, "user_id": "U001", "title": "Special Discount", "message": "Get 20% off on your next haircut!", "date": "2025-04-28", "read": False}
]

# Function to listen for queue updates
def listen_to_queue_updates():
    try:
        for message in consumer:
            event = message.value
            if event["event_type"] == "queue_status_changed":
                client_id = event["data"]["client_id"]
                queue_id = event["data"]["queue_id"]
                status = event["data"]["status"]
                position = event["data"]["position"]
                estimated_wait = event["data"]["estimated_wait"]

                # Create new notification
                new_notification = {
                    "id": str(len(sample_notifications) + 1),
                    "user_id": client_id,
                    "title": "Queue Status Update",
                    "message": f"Your queue status is '{status.upper()}'. Position: {position}, Estimated wait: {estimated_wait} mins.",
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "read": False
                }
                sample_notifications.append(new_notification)

                # Refresh if current user matches
                if current_user and (current_user.get("client_id") == client_id or current_user.get("id") == client_id):
                    app.after(0, refresh_notifications)
    except Exception as e:
        print(f"Error in Kafka consumer: {e}")
        time.sleep(5)  # Wait before attempting to reconnect

# Start the listener in a background thread
listener_thread = threading.Thread(target=listen_to_queue_updates, daemon=True)
listener_thread.start()

# Function to switch between frames
def show_frame(frame_name):
    global current_frame
    if current_frame:
        frames[current_frame].pack_forget()
    
    frames[frame_name].pack(fill="both", expand=True)
    current_frame = frame_name
    
    # Special handling for some frames
    if frame_name == "dashboard" and current_user:
        welcome_label.configure(text=f"Welcome, {current_user['name']}!")
    elif frame_name == "notifications" and current_user:
        refresh_notifications()
    elif frame_name == "appointments" and current_user:
        refresh_appointments()

# Create all frames
def create_frames():
    frame_list = ["login", "register", "dashboard", "booking", "queue", "appointments", "notifications"]
    
    for name in frame_list:
        frames[name] = ctk.CTkFrame(app)
        frames[name].pack_forget()
    
    setup_login_frame()
    setup_register_frame()
    setup_dashboard_frame()
    setup_booking_frame()
    setup_queue_frame()
    setup_appointments_frame()
    setup_notifications_frame()

# Status message display function
def show_status_message(status_label, message, color="green", duration=3000):
    status_label.configure(text=message, text_color=color)
    app.after(duration, lambda: status_label.configure(text=""))

# Login frame
def setup_login_frame():
    global username_login_entry, password_login_entry

    frame = frames["login"]

    # Title
    title = ctk.CTkLabel(frame, text="✂️ Barber Master Pro", font=TITLE_FONT)
    title.pack(pady=(50, 10))
    
    subtitle = ctk.CTkLabel(frame, text="Login to Your Account", font=HEADER_FONT)
    subtitle.pack(pady=(0, 30))

    # Username
    username_label = ctk.CTkLabel(frame, text="Username:", font=NORMAL_FONT)
    username_label.pack(pady=(10, 5))
    username_login_entry = ctk.CTkEntry(frame, width=300, font=NORMAL_FONT)
    username_login_entry.pack(pady=(0, 10))

    # Password
    password_label = ctk.CTkLabel(frame, text="Password:", font=NORMAL_FONT)
    password_label.pack(pady=(10, 5))
    password_login_entry = ctk.CTkEntry(frame, width=300, show="*", font=NORMAL_FONT)
    password_login_entry.pack(pady=(0, 20))

    # Status message
    global login_status
    login_status = ctk.CTkLabel(frame, text="", text_color="red", font=NORMAL_FONT)
    login_status.pack(pady=(0, 10))

    # Login button
    def login():
        username = username_login_entry.get()
        password = password_login_entry.get()

        if not username or not password:
            show_status_message(login_status, "Please enter username and password", "red")
            return

        login_status.configure(text="Logging in...", text_color="white")

        try:
            response = requests.post(
                f"{AUTH_API_URL}/login/",
                json={"username": username, "password": password},
                timeout=5  # Add timeout
            )
            if response.status_code == 200:
                data = response.json()
                global current_user
                current_user = data["client"]
                current_user["client_id"] = data["client_id"]
                show_status_message(login_status, "Login successful!", "green")
                show_frame("dashboard")
            else:
                error_detail = response.json().get("detail", "Invalid username or password")
                show_status_message(login_status, f"Error: {error_detail}", "red")
        except requests.RequestException as e:
            show_status_message(login_status, f"Connection error: {str(e)}", "red")

    login_button = ctk.CTkButton(frame, text="Login", command=login, width=300, font=BUTTON_FONT)
    login_button.pack(pady=(10, 10))

    # Register link
    def go_to_register():
        show_frame("register")

    register_link = ctk.CTkButton(frame, text="Don't have an account? Register", 
                                  command=go_to_register, fg_color="transparent", hover=False, 
                                  font=NORMAL_FONT)
    register_link.pack(pady=(10, 0))

# Register frame
def setup_register_frame():
    global username_register_entry, password_register_entry, name_register_entry

    frame = frames["register"]

    title = ctk.CTkLabel(frame, text="✂️ Barber Master Pro", font=TITLE_FONT)
    title.pack(pady=(30, 10))
    
    subtitle = ctk.CTkLabel(frame, text="Create a New Account", font=HEADER_FONT)
    subtitle.pack(pady=(0, 20))

    username_label = ctk.CTkLabel(frame, text="Username:", font=NORMAL_FONT)
    username_label.pack(pady=(10, 5))
    username_register_entry = ctk.CTkEntry(frame, width=300, font=NORMAL_FONT)
    username_register_entry.pack(pady=(0, 5))

    password_label = ctk.CTkLabel(frame, text="Password:", font=NORMAL_FONT)
    password_label.pack(pady=(5, 5))
    password_register_entry = ctk.CTkEntry(frame, width=300, show="*", font=NORMAL_FONT)
    password_register_entry.pack(pady=(0, 5))

    name_label = ctk.CTkLabel(frame, text="Full Name:", font=NORMAL_FONT)
    name_label.pack(pady=(5, 5))
    name_register_entry = ctk.CTkEntry(frame, width=300, font=NORMAL_FONT)
    name_register_entry.pack(pady=(0, 5))

    global register_status
    register_status = ctk.CTkLabel(frame, text="", text_color="red", font=NORMAL_FONT)
    register_status.pack(pady=(10, 10))

    def register():
        username = username_register_entry.get()
        password = password_register_entry.get()
        name = name_register_entry.get()

        if not username or not password or not name:
            show_status_message(register_status, "Please fill all fields", "red")
            return

        try:
            response = requests.post(
                f"{AUTH_API_URL}/register/",
                json={
                    "username": username,
                    "password": password,
                    "name": name,
                    "email": f"{username}@example.com",
                    "phone": "09123456789"
                },
                timeout=5
            )
            if response.status_code == 200:
                data = response.json()
                show_status_message(
                    register_status,
                    f"Registration successful! Logging you in...", 
                    "green"
                )

                # Auto-login after registration
                try:
                    login_response = requests.post(
                        f"{AUTH_API_URL}/login/",
                        json={
                            "username": username,
                            "password": password
                        },
                        timeout=5
                    )
                    if login_response.status_code == 200:
                        login_data = login_response.json()
                        global current_user
                        current_user = login_data["client"]
                        current_user["client_id"] = login_data["client_id"]
                        show_frame("dashboard")
                    else:
                        show_status_message(
                            register_status,
                            "Registration succeeded but auto-login failed. Please login manually.",
                            "orange"
                        )
                except Exception as e:
                    show_status_message(
                        register_status,
                        f"Auto-login error: {str(e)}", 
                        "red"
                    )

            else:
                show_status_message(
                    register_status,
                    f"Error: {response.json().get('detail', 'Unknown')}", 
                    "red"
                )

        except Exception as e:
            show_status_message(register_status, f"Server error: {str(e)}", "red")

    register_button = ctk.CTkButton(frame, text="Register", command=register, width=300, font=BUTTON_FONT)
    register_button.pack(pady=(10, 10))

    def go_to_login():
        show_frame("login")

    login_link = ctk.CTkButton(frame, text="Already have an account? Login", 
                               command=go_to_login, fg_color="transparent", hover=False, font=NORMAL_FONT)
    login_link.pack(pady=(10, 0))

# Dashboard frame
def setup_dashboard_frame():
    frame = frames["dashboard"]
    
    # Welcome message
    global welcome_label
    welcome_label = ctk.CTkLabel(frame, text="Welcome!", font=TITLE_FONT)
    welcome_label.pack(pady=(50, 30))
    
    # Status message
    dashboard_status = ctk.CTkLabel(frame, text="", font=NORMAL_FONT)
    dashboard_status.pack(pady=(0, 10))
    
    # Button frame
    button_frame = ctk.CTkFrame(frame, fg_color="transparent")
    button_frame.pack(pady=20)
    
    # Booking button
    def go_to_booking():
        show_frame("booking")
    
    booking_button = ctk.CTkButton(button_frame, text="Book Appointment", command=go_to_booking, 
                                  width=220, height=120, font=BUTTON_FONT, 
                                  fg_color="#4B5563", hover_color="#374151")
    booking_button.grid(row=0, column=0, padx=10, pady=10)
    
    # Queue button
    def go_to_queue():
        show_frame("queue")
    
    queue_button = ctk.CTkButton(button_frame, text="Join Queue", command=go_to_queue, 
                               width=220, height=120, font=BUTTON_FONT,
                               fg_color="#4B5563", hover_color="#374151")
    queue_button.grid(row=0, column=1, padx=10, pady=10)
    
    # View appointments button
    def go_to_appointments():
        show_frame("appointments")
    
    appointments_button = ctk.CTkButton(button_frame, text="My Appointments", command=go_to_appointments, 
                                      width=220, height=120, font=BUTTON_FONT,
                                      fg_color="#4B5563", hover_color="#374151")
    appointments_button.grid(row=1, column=0, padx=10, pady=10)
    
    # Notifications button
    def go_to_notifications():
        show_frame("notifications")
    
    notifications_button = ctk.CTkButton(button_frame, text="Notifications", command=go_to_notifications, 
                                       width=220, height=120, font=BUTTON_FONT,
                                       fg_color="#4B5563", hover_color="#374151")
    notifications_button.grid(row=1, column=1, padx=10, pady=10)
    
    # Logout button
    def logout():
        result = True
        global current_user
        if current_user:
            result = ctk.CTkMessagebox.CTkMessagebox(
                master=app,
                title="Logout Confirmation",
                message="Are you sure you want to logout?",
                icon="question",
                option_1="Yes",
                option_2="No"
            ).get()
        
        if result == "Yes" or result is True:  # If Yes or no messagebox shown
            current_user = None
            show_frame("login")
            show_status_message(dashboard_status, "You have been logged out", "blue")
    
    logout_button = ctk.CTkButton(frame, text="Logout", command=logout, 
                                 fg_color="#991B1B", hover_color="#7F1D1D", 
                                 width=200, font=BUTTON_FONT)
    logout_button.pack(pady=(30, 0))

# Booking frame
def setup_booking_frame():
    frame = frames["booking"]
    
    # Title
    title = ctk.CTkLabel(frame, text="Book an Appointment", font=TITLE_FONT)
    title.pack(pady=(30, 20))
    
    # Form container
    form_frame = ctk.CTkFrame(frame, fg_color="transparent")
    form_frame.pack(pady=10)
    
    # Barber selection
    barber_label = ctk.CTkLabel(form_frame, text="Select Barber:", font=NORMAL_FONT)
    barber_label.grid(row=0, column=0, sticky="w", padx=10, pady=(10, 5))
    
    barber_var = tk.StringVar()
    barber_names = [barber["name"] for barber in sample_barbers]
    barber_dropdown = ctk.CTkOptionMenu(form_frame, variable=barber_var, values=barber_names, 
                                       width=300, font=NORMAL_FONT, dropdown_font=NORMAL_FONT)
    barber_dropdown.grid(row=0, column=1, padx=10, pady=(10, 5))
    if barber_names:
        barber_dropdown.set(barber_names[0])
    
    # Service selection
    service_label = ctk.CTkLabel(form_frame, text="Select Service:", font=NORMAL_FONT)
    service_label.grid(row=1, column=0, sticky="w", padx=10, pady=(10, 5))
    
    service_var = tk.StringVar()
    service_names = [f"{service['name']} (${service['price']})" for service in sample_services]
    service_dropdown = ctk.CTkOptionMenu(form_frame, variable=service_var, values=service_names, 
                                        width=300, font=NORMAL_FONT, dropdown_font=NORMAL_FONT)
    service_dropdown.grid(row=1, column=1, padx=10, pady=(10, 5))
    if service_names:
        service_dropdown.set(service_names[0])
    
    # Date selection
    date_label = ctk.CTkLabel(form_frame, text="Date (YYYY-MM-DD):", font=NORMAL_FONT)
    date_label.grid(row=2, column=0, sticky="w", padx=10, pady=(10, 5))
    date_entry = ctk.CTkEntry(form_frame, width=300, font=NORMAL_FONT)
    date_entry.grid(row=2, column=1, padx=10, pady=(10, 5))
    date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
    
    # Time selection
    time_label = ctk.CTkLabel(form_frame, text="Time (HH:MM):", font=NORMAL_FONT)
    time_label.grid(row=3, column=0, sticky="w", padx=10, pady=(10, 5))
    time_entry = ctk.CTkEntry(form_frame, width=300, font=NORMAL_FONT)
    time_entry.grid(row=3, column=1, padx=10, pady=(10, 5))
    time_entry.insert(0, "09:00")
    
    # Status message
    status = ctk.CTkLabel(frame, text="", text_color="green", font=NORMAL_FONT)
    status.pack(pady=(5, 10))
    
    # Book button
    def book_appointment():
        if not current_user:
            show_status_message(status, "Please login first", "red")
            return

        date = date_entry.get()
        time_val = time_entry.get()
        barber_name = barber_var.get()
        service_name = service_var.get().split(" (")[0]  # Extract service name only

        # Validate inputs
        if not date or not time_val:
            show_status_message(status, "Please enter date and time", "red")
            return

        try:
            datetime.strptime(date, "%Y-%m-%d")
        except ValueError:
            show_status_message(status, "Invalid date format. Use YYYY-MM-DD", "red")
            return

        try:
            datetime.strptime(time_val, "%H:%M")
        except ValueError:
            show_status_message(status, "Invalid time format. Use HH:MM", "red")
            return

        # Find barber and service by name
        barber = next((b for b in sample_barbers if b["name"] == barber_name), None)
        service = next((s for s in sample_services if s["name"] == service_name), None)

        if not barber or not service:
            show_status_message(status, "Invalid barber or service selection", "red")
            return

        user_id = current_user.get("id") or current_user.get("client_id")

        # Show loading state
        status.configure(text="Processing booking...", text_color="blue")
        
        try:
            # Send to API
            payload = {
                "client_id": user_id,
                "barber_id": barber["barber_id"],    
                "service_type": service["id"],       
                "booking_date": date,
                "booking_time": time_val
            }
            
            response = requests.post(f"{API_BASE_URL}/booking/", json=payload, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                appointment_id = data.get("booking_id", "Unknown")
                
                # Store the appointment locally too
                new_appointment = {
                    "id": appointment_id,
                    "user_id": user_id,
                    "barber_id": barber["barber_id"],
                    "barber_name": barber["name"],
                    "service_id": service["id"],
                    "service_name": service["name"],
                    "datetime": f"{date} {time_val}",
                    "status": "Confirmed"
                }
                sample_appointments.append(new_appointment)

                # Create notification
                notification_id = len(sample_notifications) + 1
                new_notification = {
                    "id": notification_id,
                    "user_id": user_id,
                    "title": "Appointment Confirmed",
                    "message": f"Your appointment with {barber_name} for {service_name} on {date} at {time_val} is confirmed!",
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "read": False
                }
                sample_notifications.append(new_notification)

                # Send notification event to Kafka
                producer.send('notification-updated', {
                    "event_type": "appointment_booked",
                    "data": {
                        "client_id": user_id,
                        "appointment_id": appointment_id,
                        "barber_name": barber_name,
                        "service_name": service_name,
                        "datetime": f"{date} {time_val}"
                    }
                })
                producer.flush()

                show_status_message(status, f"Appointment booked! ID: {appointment_id}", "green")
                
                # Reset form or show confirmation
                ctk.CTkMessagebox.CTkMessagebox(
                    master=app,
                    title="Booking Successful",
                    message=f"Your appointment has been booked!\n\nBarber: {barber_name}\nService: {service_name}\nDate: {date}\nTime: {time_val}",
                    icon="check"
                )
            else:
                error_msg = response.json().get('detail', 'Unknown error')
                show_status_message(status, f"Booking failed: {error_msg}", "red")
        
        except requests.RequestException as e:
            show_status_message(status, f"Connection error: {str(e)}", "red")
        except Exception as e:
            show_status_message(status, f"Error: {str(e)}", "red")

    book_button = ctk.CTkButton(frame, text="Book Appointment", command=book_appointment, 
                              width=300, font=BUTTON_FONT,
                              fg_color="#047857", hover_color="#065F46")
    book_button.pack(pady=(0, 10))
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, 
                              fg_color="transparent", hover_color="#374151", font=NORMAL_FONT)
    back_button.pack(pady=(10, 0))

# Queue frame
def setup_queue_frame():
    frame = frames["queue"]

    # Title
    title = ctk.CTkLabel(frame, text="Join the Queue", font=TITLE_FONT)
    title.pack(pady=(30, 20))

    # Queue container
    queue_container = ctk.CTkFrame(frame, fg_color="transparent")
    queue_container.pack(pady=10, fill="both", expand=True)

    # Current queue status
    queue_status_label = ctk.CTkLabel(queue_container, text="Current Queue Status:", font=HEADER_FONT)
    queue_status_label.pack(pady=(10, 5))

    queue_count = ctk.CTkLabel(queue_container, text=f"People in queue: {len(sample_queue)}", font=NORMAL_FONT)
    queue_count.pack(pady=(0, 20))

    # Form container
    form_frame = ctk.CTkFrame(queue_container, fg_color="transparent")
    form_frame.pack(pady=10)

    # Barber selection
    barber_label = ctk.CTkLabel(form_frame, text="Select Barber (Optional):", font=NORMAL_FONT)
    barber_label.grid(row=0, column=0, sticky="w", padx=10, pady=(10, 5))
    
    barber_var = tk.StringVar(value="Any Available")
    barber_names = ["Any Available"] + [barber["name"] for barber in sample_barbers]
    barber_dropdown = ctk.CTkOptionMenu(form_frame, variable=barber_var, values=barber_names, 
                                       width=300, font=NORMAL_FONT, dropdown_font=NORMAL_FONT)
    barber_dropdown.grid(row=0, column=1, padx=10, pady=(10, 5))

    # Service selection
    service_label = ctk.CTkLabel(form_frame, text="Select Service:", font=NORMAL_FONT)
    service_label.grid(row=1, column=0, sticky="w", padx=10, pady=(10, 5))
    
    service_var = tk.StringVar()
    service_names = [service["name"] for service in sample_services]
    service_dropdown = ctk.CTkOptionMenu(form_frame, variable=service_var, values=service_names, 
                                        width=300, font=NORMAL_FONT, dropdown_font=NORMAL_FONT)
    service_dropdown.grid(row=1, column=1, padx=10, pady=(10, 5))
    if service_names:
        service_dropdown.set(service_names[0])

    # Status message
    status = ctk.CTkLabel(queue_container, text="", text_color="green", font=NORMAL_FONT)
    status.pack(pady=(10, 10))

    # Join queue button
    def join_queue():
        if not current_user:
            show_status_message(status, "Please login first", "red")
            return

        barber_name = barber_var.get()
        service_name = service_var.get()

        # Get user ID
        user_id = current_user.get("id") or current_user.get("client_id")

        # Check if user is already in queue
        if any(q["user_id"] == user_id for q in sample_queue):
            show_status_message(status, "You are already in the queue", "red")
            return

        # Find barber_id and service_id
        barber_id = None
        if barber_name != "Any Available":
            barber = next((b for b in sample_barbers if b["name"] == barber_name), None)
            if barber:
                barber_id = barber["barber_id"]
            else:
                show_status_message(status, "Selected barber not found", "red")
                return

        service = next((s for s in sample_services if s["name"] == service_name), None)
        if not service:
            show_status_message(status, "Selected service not found", "red")
            return

        # Show loading state
        status.configure(text="Joining queue...", text_color="blue")

        try:
            # Send to API
            payload = {
                "client_id": user_id,
                "service_type": service["id"],
                "barber_id": barber_id  # Can be None
            }
            
            response = requests.post(f"{API_BASE_URL}/queue/", json=payload, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                queue_id = data.get("queue_id", f"Q{len(sample_queue) + 1:03d}")
                position = data.get("position", len(sample_queue) + 1)
                wait_time = data.get("estimated_wait", position * 15)
                
                # Add to local queue
                # Add to local queue
                queue_entry = {
                    "id": queue_id,
                    "user_id": user_id,
                    "user_name": current_user["name"],
                    "barber_preference": None if barber_name == "Any Available" else barber_name,
                    "service": service_name,
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "status": "Waiting",
                    "position": position,
                    "wait_time": wait_time
                }
                sample_queue.append(queue_entry)

                # Send Kafka Event
                producer.send('queue-updated', {
                    "event_type": "queue_status_changed",
                    "data": {
                        "client_id": user_id,
                        "queue_id": queue_id,
                        "status": "waiting",
                        "position": position,
                        "estimated_wait": wait_time
                    }
                })
                producer.flush()

                # Add notification
                notification_id = len(sample_notifications) + 1
                new_notification = {
                    "id": notification_id,
                    "user_id": user_id,
                    "title": "Joined Queue",
                    "message": f"You've joined the queue! Position: {position}, Estimated wait: {wait_time} minutes",
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "read": False
                }
                sample_notifications.append(new_notification)

                # Update UI
                queue_count.configure(text=f"People in queue: {len(sample_queue)}")
                show_status_message(status, f"Added to queue! Your position: {position}", "green")
                
                # Show confirmation dialog
                ctk.CTkMessagebox.CTkMessagebox(
                    master=app,
                    title="Queue Joined",
                    message=f"You've successfully joined the queue!\n\nYour position: {position}\nEstimated wait: {wait_time} minutes",
                    icon="check"
                )
                
                # Update queue display
                update_queue_display()
            else:
                error_msg = response.json().get('detail', 'Unknown error')
                show_status_message(status, f"Failed to join queue: {error_msg}", "red")
        
        except requests.RequestException as e:
            show_status_message(status, f"Connection error: {str(e)}", "red")
        except Exception as e:
            show_status_message(status, f"Error: {str(e)}", "red")

    queue_button = ctk.CTkButton(queue_container, text="Join Queue", command=join_queue, 
                               width=300, font=BUTTON_FONT,
                               fg_color="#047857", hover_color="#065F46")
    queue_button.pack(pady=(0, 10))

    # Current queue display
    queue_display_frame = ctk.CTkFrame(queue_container)
    queue_display_frame.pack(pady=10, fill="both", expand=True, padx=20)

    # Queue header
    queue_header = ctk.CTkLabel(queue_display_frame, text="Current Queue", font=HEADER_FONT)
    queue_header.pack(pady=(10, 5))

    queue_list = ctk.CTkTextbox(queue_display_frame, height=150, font=NORMAL_FONT)
    queue_list.pack(fill="both", expand=True, padx=5, pady=5)

    def update_queue_display():
        queue_list.delete("1.0", tk.END)
        if not sample_queue:
            queue_list.insert("1.0", "Queue is currently empty")
            return

        for i, q in enumerate(sample_queue):
            queue_list.insert(tk.END, f"{i+1}. {q['user_name']} - Service: {q['service']}")
            if q['barber_preference']:
                queue_list.insert(tk.END, f" - Barber: {q['barber_preference']}")
            queue_list.insert(tk.END, f" - Status: {q['status']}\n")

    update_queue_display()

    # Refresh button
    def refresh_queue():
        try:
            response = requests.get(f"{API_BASE_URL}/queue/", timeout=5)
            if response.status_code == 200:
                data = response.json()
                global sample_queue
                sample_queue = data.get("queue", [])
                queue_count.configure(text=f"People in queue: {len(sample_queue)}")
                update_queue_display()
                show_status_message(status, "Queue refreshed", "green")
            else:
                show_status_message(status, "Failed to refresh queue", "red")
        except Exception as e:
            show_status_message(status, f"Error refreshing queue: {str(e)}", "red")

    refresh_button = ctk.CTkButton(queue_container, text="Refresh Queue", command=refresh_queue, 
                                 width=200, font=NORMAL_FONT)
    refresh_button.pack(pady=(10, 0))

    # Back button
    def go_back():
        show_frame("dashboard")

    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, 
                              fg_color="transparent", hover_color="#374151", font=NORMAL_FONT)
    back_button.pack(pady=(10, 20))

# Appointments frame
def setup_appointments_frame():
    frame = frames["appointments"]
    
    # Title
    title = ctk.CTkLabel(frame, text="My Appointments", font=TITLE_FONT)
    title.pack(pady=(30, 20))
    
    # Appointments container
    appointments_container = ctk.CTkFrame(frame, fg_color="transparent")
    appointments_container.pack(pady=10, fill="both", expand=True)
    
    # Status message
    status = ctk.CTkLabel(appointments_container, text="", font=NORMAL_FONT)
    status.pack(pady=(0, 10))
    
    # Create appointment list
    table_frame = ttk.Frame(appointments_container)
    table_frame.pack(pady=10, fill="both", expand=True, padx=20)
    
    # Configure ttk style
    style = ttk.Style()
    style.configure("Treeview", rowheight=25, font=('Helvetica', 11))
    style.configure("Treeview.Heading", font=('Helvetica', 12, 'bold'))
    
    columns = ("ID", "Barber", "Service", "Date & Time", "Status")
    global appointments_table
    appointments_table = ttk.Treeview(table_frame, columns=columns, show="headings")
    
    for col in columns:
        appointments_table.heading(col, text=col)
        appointments_table.column(col, anchor="center")
    
    appointments_table.pack(fill="both", expand=True)
    
    # Add scrollbar
    scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=appointments_table.yview)
    appointments_table.configure(yscroll=scrollbar.set)
    scrollbar.pack(side="right", fill="y")
    
    # Function to refresh appointments
    def refresh_appointments():
        for row in appointments_table.get_children():
            appointments_table.delete(row)
        
        if not current_user:
            return
        
        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        try:
            response = requests.get(f"{API_BASE_URL}/booking/client/{user_id}", timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                user_appointments = data.get("bookings", [])
                
                # Update local appointments
                global sample_appointments
                sample_appointments = user_appointments
                
                if not user_appointments:
                    appointments_table.insert("", "end", values=("No appointments", "", "", "", ""))
                    return
                
                for appointment in user_appointments:
                    appointments_table.insert("", "end", values=(
                        appointment.get("booking_id", ""),
                        appointment.get("barber_name", ""),
                        appointment.get("service_name", ""),
                        f"{appointment.get('booking_date', '')} {appointment.get('booking_time', '')}",
                        appointment.get("status", "Confirmed")
                    ))
                
                show_status_message(status, "Appointments refreshed", "green")
            else:
                # Fall back to local data if API fails
                user_appointments = [a for a in sample_appointments if a["user_id"] == user_id]
                
                if not user_appointments:
                    appointments_table.insert("", "end", values=("No appointments", "", "", "", ""))
                    return
                
                for appointment in user_appointments:
                    appointments_table.insert("", "end", values=(
                        appointment["id"],
                        appointment["barber_name"],
                        appointment["service_name"],
                        appointment["datetime"],
                        appointment["status"]
                    ))
                
                show_status_message(status, "Using local data (API unavailable)", "orange")
        except Exception as e:
            # Fall back to local data if API fails
            user_appointments = [a for a in sample_appointments if a["user_id"] == user_id]
            
            if not user_appointments:
                appointments_table.insert("", "end", values=("No appointments", "", "", "", ""))
                return
            
            for appointment in user_appointments:
                appointments_table.insert("", "end", values=(
                    appointment["id"],
                    appointment["barber_name"],
                    appointment["service_name"],
                    appointment["datetime"],
                    appointment["status"]
                ))
            
            show_status_message(status, f"Connection error: {str(e)}", "red")
    
    # Cancel button
    def cancel_appointment():
        selected = appointments_table.selection()
        if not selected:
            show_status_message(status, "Please select an appointment to cancel", "red")
            return

        item = appointments_table.item(selected[0])
        appointment_id = item["values"][0]

        if appointment_id == "No appointments":
            return

        # Show confirmation dialog
        result = ctk.CTkMessagebox.CTkMessagebox(
            master=app,
            title="Cancel Appointment",
            message="Are you sure you want to cancel this appointment?",
            icon="question",
            option_1="Yes",
            option_2="No"
        ).get()
        
        if result != "Yes":
            return

        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        try:
            response = requests.delete(f"{API_BASE_URL}/booking/{appointment_id}", timeout=5)
            
            if response.status_code == 200:
                # Update local data
                for i, appointment in enumerate(sample_appointments):
                    if appointment["id"] == appointment_id:
                        # Add a notification about cancellation
                        notification_id = len(sample_notifications) + 1
                        notification = {
                            "id": notification_id,
                            "user_id": user_id,
                            "title": "Appointment Cancelled",
                            "message": f"Your appointment with {appointment['barber_name']} for {appointment['service_name']} has been cancelled.",
                            "date": datetime.now().strftime("%Y-%m-%d"),
                            "read": False
                        }
                        sample_notifications.append(notification)
                        
                        # Remove the appointment
                        del sample_appointments[i]
                        break

                # Refresh list
                refresh_appointments()
                show_status_message(status, "Appointment cancelled successfully", "green")
            else:
                error_msg = response.json().get('detail', 'Unknown error')
                show_status_message(status, f"Failed to cancel: {error_msg}", "red")
        except Exception as e:
            # Fallback to local operation
            for i, appointment in enumerate(sample_appointments):
                if appointment["id"] == appointment_id:
                    # Add a notification about cancellation
                    notification_id = len(sample_notifications) + 1
                    notification = {
                        "id": notification_id,
                        "user_id": user_id,
                        "title": "Appointment Cancelled",
                        "message": f"Your appointment with {appointment['barber_name']} for {appointment['service_name']} has been cancelled.",
                        "date": datetime.now().strftime("%Y-%m-%d"),
                        "read": False
                    }
                    sample_notifications.append(notification)
                    
                    # Remove the appointment
                    del sample_appointments[i]
                    break

            # Refresh list
            refresh_appointments()
            show_status_message(status, "Appointment cancelled locally (API unavailable)", "orange")
    
    button_frame = ctk.CTkFrame(appointments_container, fg_color="transparent")
    button_frame.pack(pady=10)
    
    cancel_button = ctk.CTkButton(button_frame, text="Cancel Selected Appointment", 
                                command=cancel_appointment, fg_color="#991B1B", 
                                hover_color="#7F1D1D", width=250, font=NORMAL_FONT)
    cancel_button.grid(row=0, column=0, padx=10)
    
    refresh_button = ctk.CTkButton(button_frame, text="Refresh", 
                                 command=refresh_appointments, width=200, font=NORMAL_FONT)
    refresh_button.grid(row=0, column=1, padx=10)
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, 
                              fg_color="transparent", hover_color="#374151", font=NORMAL_FONT)
    back_button.pack(pady=(10, 20))

# Notifications frame
def setup_notifications_frame():
    frame = frames["notifications"]
    
    # Title
    title = ctk.CTkLabel(frame, text="My Notifications", font=TITLE_FONT)
    title.pack(pady=(30, 20))
    
    # Notifications container
    notifications_container = ctk.CTkFrame(frame, fg_color="transparent")
    notifications_container.pack(pady=10, fill="both", expand=True)
    
    # Status message
    status = ctk.CTkLabel(notifications_container, text="", font=NORMAL_FONT)
    status.pack(pady=(0, 10))
    
    # Create notifications list
    table_frame = ttk.Frame(notifications_container)
    table_frame.pack(pady=10, fill="both", expand=True, padx=20)
    
    # Configure ttk style
    style = ttk.Style()
    style.configure("Treeview", rowheight=25, font=('Helvetica', 11))
    style.configure("Treeview.Heading", font=('Helvetica', 12, 'bold'))
    
    columns = ("ID", "Title", "Message", "Date", "Status")
    global notifications_table
    notifications_table = ttk.Treeview(table_frame, columns=columns, show="headings")
    
    # Configure column headings and widths
    notifications_table.heading("ID", text="ID")
    notifications_table.column("ID", width=50, anchor="center")
    
    notifications_table.heading("Title", text="Title")
    notifications_table.column("Title", width=100, anchor="w")
    
    notifications_table.heading("Message", text="Message")
    notifications_table.column("Message", width=300, anchor="w")
    
    notifications_table.heading("Date", text="Date")
    notifications_table.column("Date", width=100, anchor="center")
    
    notifications_table.heading("Status", text="Status")
    notifications_table.column("Status", width=80, anchor="center")
    
    notifications_table.pack(fill="both", expand=True)
    
    # Add scrollbar
    scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=notifications_table.yview)
    notifications_table.configure(yscroll=scrollbar.set)
    scrollbar.pack(side="right", fill="y")
    
    # Mark as read button
    def mark_as_read():
        if not current_user:
            return
        
        selected = notifications_table.selection()
        if not selected:
            show_status_message(status, "Please select notifications to mark as read", "red")
            return
        
        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        for item_id in selected:
            item = notifications_table.item(item_id)
            notification_id = item["values"][0]
            
            # Find and update notification
            for i, notification in enumerate(sample_notifications):
                if str(notification["id"]) == str(notification_id) and notification["user_id"] == user_id:
                    sample_notifications[i]["read"] = True
                    break
        
        refresh_notifications()
        show_status_message(status, "Notifications marked as read", "green")
    
    buttons_frame = ctk.CTkFrame(notifications_container, fg_color="transparent")
    buttons_frame.pack(pady=10)
    
    mark_read_button = ctk.CTkButton(buttons_frame, text="Mark as Read", 
                                   command=mark_as_read, width=200, font=NORMAL_FONT)
    mark_read_button.grid(row=0, column=0, padx=10)
    
    # Mark all as read button
    def mark_all_as_read():
        if not current_user:
            return
        
        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        # Count unread notifications
        unread_count = sum(1 for n in sample_notifications if n["user_id"] == user_id and not n["read"])
        
        if unread_count == 0:
            show_status_message(status, "No unread notifications", "blue")
            return
        
        for i, notification in enumerate(sample_notifications):
            if notification["user_id"] == user_id:
                sample_notifications[i]["read"] = True
        
        refresh_notifications()
        show_status_message(status, f"{unread_count} notifications marked as read", "green")
    
    mark_all_button = ctk.CTkButton(buttons_frame, text="Mark All as Read", 
                                  command=mark_all_as_read, width=200, font=NORMAL_FONT)
    mark_all_button.grid(row=0, column=1, padx=10)
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, 
                              fg_color="transparent", hover_color="#374151", font=NORMAL_FONT)
    back_button.pack(pady=(10, 20))

# Function to refresh notifications display
def refresh_notifications():
    if not current_user or 'notifications_table' not in globals():
        return
        
    # Clear existing items
    for row in notifications_table.get_children():
        notifications_table.delete(row)
    
    # Get user_id safely
    user_id = current_user.get("id") or current_user.get("client_id")
    
    # Get user notifications
    user_notifications = [n for n in sample_notifications if n["user_id"] == user_id]
    
    if not user_notifications:
        notifications_table.insert("", "end", values=("", "No notifications", "", "", ""))
        return
    
    # Sort by unread first, then latest first
    user_notifications.sort(key=lambda x: (x["read"], -int(str(x["id"]))))
    
    # Add user notifications to table
    for notification in user_notifications:
        status_text = "Read" if notification["read"] else "Unread"
        
        # Highlight unread notifications with tag
        tags = ("unread",) if not notification["read"] else ()
        
        notifications_table.insert("", "end", values=(
            notification["id"],
            notification["title"],
            notification["message"],
            notification["date"],
            status_text
        ), tags=tags)
    
    # Configure tag appearance
    notifications_table.tag_configure("unread", background="#053B50")

# Function to check server status
def check_server_status():
    try:
        response = requests.get(f"{API_BASE_URL}/health/", timeout=2)
        if response.status_code == 200:
            return True
        return False
    except:
        return False

# Attempt to get barbers and services from API
def get_barbers_and_services():
    global sample_barbers, sample_services
    
    try:
        # Get barbers
        response = requests.get(f"{API_BASE_URL}/barbers/", timeout=5)
        if response.status_code == 200:
            barbers_data = response.json()
            if barbers_data and "barbers" in barbers_data:
                sample_barbers = barbers_data["barbers"]
        
        # Get services
        response = requests.get(f"{API_BASE_URL}/services/", timeout=5)
        if response.status_code == 200:
            services_data = response.json()
            if services_data and "services" in services_data:
                sample_services = services_data["services"]
    except Exception as e:
        print(f"Error fetching barbers and services: {e}")

# Error handling for CTkMessagebox
try:
    from tkinter import messagebox
    ctk.CTkMessagebox = type('CTkMessagebox', (), {
        'CTkMessagebox': lambda **kwargs: messagebox.showinfo(
            kwargs.get('title', 'Information'),
            kwargs.get('message', ''),
            icon=kwargs.get('icon', 'info')
        ) or kwargs.get('option_1', 'OK')
    })
except ImportError:
    # Fallback if CTkMessagebox is not available
    class FallbackMessageBox:
        def CTkMessagebox(self, **kwargs):
            result = messagebox.showinfo(
                kwargs.get('title', 'Information'),
                kwargs.get('message', '')
            )
            return kwargs.get('option_1', 'OK')
    
    ctk.CTkMessagebox = FallbackMessageBox()

# Create all frames and start with login
create_frames()
show_frame("login")

# Try to get barbers and services in background
get_barbers_thread = threading.Thread(target=get_barbers_and_services, daemon=True)
get_barbers_thread.start()

# Start the app
app.mainloop()