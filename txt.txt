#barber_service.py
import json
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from kafka import KafkaConsumer, KafkaProducer
import threading

# Kafka constants
KAFKA_BROKER = "localhost:9092"
TOPIC_FEEDBACK_SUBMITTED = "feedback-submitted"
TOPIC_BARBER_FEEDBACK = "barber-feedback"

# Define FastAPI app
app = FastAPI()

# Configure Kafka consumer
consumer = KafkaConsumer(
    TOPIC_FEEDBACK_SUBMITTED,
    bootstrap_servers=[KAFKA_BROKER],
    auto_offset_reset='earliest',
    enable_auto_commit=True,
    group_id='barber-group',
    value_deserializer=lambda x: json.loads(x.decode('utf-8'))
)

# Configure Kafka producer
producer = KafkaProducer(
    bootstrap_servers=[KAFKA_BROKER],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Database simulation for barbers and their feedback
barbers_db = {
    "B001": {
        "barber_id": "B001",
        "name": "John Smith",
        "specialties": ["Classic Cut", "Beard Trim"],
        "available": True
    },
    "B002": {
        "barber_id": "B002",
        "name": "Mike Johnson",
        "specialties": ["Fade", "Hair Coloring"],
        "available": True
    },
    "B003": {
        "barber_id": "B003",
        "name": "Sarah Williams",
        "specialties": ["Styling", "Hair Treatment"],
        "available": True
    }
}

# Database for barber feedback
barber_feedback_db = {}

# Service types
service_types = [
    {"id": "S001", "name": "Classic Haircut", "duration": 30, "price": 25.00},
    {"id": "S002", "name": "Beard Trim", "duration": 15, "price": 15.00},
    {"id": "S003", "name": "Fade", "duration": 45, "price": 35.00},
    {"id": "S004", "name": "Hair Coloring", "duration": 60, "price": 50.00},
    {"id": "S005", "name": "Hair Treatment", "duration": 45, "price": 40.00},
    {"id": "S006", "name": "Full Service (Cut + Beard)", "duration": 60, "price": 45.00}
]

# Models
class BarberAvailabilityUpdate(BaseModel):
    barber_id: str
    available: bool

# Barber endpoints
@app.get("/barbers/")
async def get_all_barbers():
    return {"barbers": list(barbers_db.values())}

@app.get("/barbers/{barber_id}")
async def get_barber(barber_id: str):
    if barber_id not in barbers_db:
        raise HTTPException(status_code=404, detail="Barber not found")
    return barbers_db[barber_id]


@app.post("/barbers/{barber_id}/availability")
async def update_barber_availability(barber_id: str, update: BarberAvailabilityUpdate):
    if barber_id not in barbers_db:
        raise HTTPException(status_code=404, detail="Barber not found")
    
    barbers_db[barber_id]["available"] = update.available
    
    return {"message": f"Barber {barber_id} availability updated", "available": update.available}

@app.get("/services/")
async def get_all_services():
    return {"services": service_types}

def process_feedback(feedback_data):
    """Process received feedback and update barber statistics"""
    barber_id = feedback_data["barber_id"]
    
    if barber_id not in barber_feedback_db:
        barber_feedback_db[barber_id] = []
    
    # Add feedback to barber's record
    barber_feedback_db[barber_id].append(feedback_data)
    
    # Calculate new average rating
    ratings = [f["rating"] for f in barber_feedback_db[barber_id]]
    avg_rating = sum(ratings) / len(ratings)
    
    # Send feedback notification to barber
    producer.send('barber-feedback', {
        "event_type": "barber_feedback_received",
        "data": {
            "barber_id": barber_id,
            "feedback": feedback_data,
            "average_rating": avg_rating,
            "total_ratings": len(ratings)
        }
    })
    
    print(f"Processed feedback for barber {barber_id}: rating {feedback_data['rating']}/5")

def kafka_consumer_thread():
    """Listen for feedback submissions"""
    print("Barber service started. Listening for feedback...")
    
    for message in consumer:
        data = message.value
        event_type = data.get("event_type")
        payload = data.get("data")
        
        if event_type == "feedback_submitted":
            process_feedback(payload)
        else:
            print(f"Unknown event type: {event_type}")

# Run the service
if __name__ == "__main__":
    # Start Kafka consumer in a separate thread
    consumer_thread = threading.Thread(target=kafka_consumer_thread, daemon=True)
    consumer_thread.start()
    
    uvicorn.run("barber_service:app", host="0.0.0.0", port=8004, reload=True)

#booking_service.py
import json
import requests
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from kafka import KafkaProducer
import uvicorn

# Kafka constants
KAFKA_BROKER = "localhost:9092"
TOPIC_BOOKING_CREATED = "booking-created"

# Define FastAPI app
app = FastAPI()

# Configure Kafka producer
producer = KafkaProducer(
    bootstrap_servers=[KAFKA_BROKER],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Database simulation for bookings
bookings_db = {}
queue_db = {}
next_queue_id = 1

# Models
class QueueRequest(BaseModel):
    client_id: str

class BookingRequest(BaseModel):
    client_id: str
    barber_id: str
    service_type: str
    booking_date: str
    booking_time: str

# Queue endpoints
@app.post("/queue/")
async def add_to_queue(request: QueueRequest):
    global next_queue_id
    
    try:
        # Check if client exists
        client_response = requests.get(f"http://localhost:8002/client/{request.client_id}")
        if client_response.status_code != 200:
            raise HTTPException(status_code=404, detail="Client not found")
        
        # Generate queue entry
        queue_id = f"Q{next_queue_id:03d}"
        next_queue_id += 1
        
        timestamp = datetime.now().isoformat()
        
        queue_entry = {
            "queue_id": queue_id,
            "client_id": request.client_id,
            "timestamp": timestamp,
            "status": "waiting"
        }
        
        # Save to local DB
        queue_db[queue_id] = queue_entry
        
        # Send message to queue-created topic
        producer.send('booking-created', {
            "event_type": "queue_created",
            "data": queue_entry
        })
        
        return {"queue_id": queue_id, "message": "Successfully added to queue"}
    
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to add to queue: {str(e)}")

@app.get("/queue/")
async def get_queue_status():
    # Return all queue entries sorted by timestamp
    sorted_queue = sorted(
        queue_db.values(),
        key=lambda x: x["timestamp"]
    )
    return {"queue": sorted_queue}

@app.get("/queue/{queue_id}")
async def get_queue_entry(queue_id: str):
    if queue_id not in queue_db:
        raise HTTPException(status_code=404, detail="Queue entry not found")
    return queue_db[queue_id]

# Booking endpoints
@app.post("/booking/")
async def create_booking(request: BookingRequest):
    try:
        # Check if client exists
        client_response = requests.get(f"http://localhost:8002/client/{request.client_id}")
        if client_response.status_code != 200:
            raise HTTPException(status_code=404, detail="Client not found")
        
        # Generate booking ID
        booking_id = f"B{len(bookings_db) + 1:03d}"
        
        # Create booking entry
        booking = {
            "booking_id": booking_id,
            "client_id": request.client_id,
            "barber_id": request.barber_id,
            "service_type": request.service_type,
            "booking_date": request.booking_date,
            "booking_time": request.booking_time,
            "created_at": datetime.now().isoformat(),
            "status": "scheduled"
        }
        
        # Save to local DB
        bookings_db[booking_id] = booking
        
        # Send message to booking-created topic
        producer.send('booking-created', {
            "event_type": "booking_created",
            "data": booking
        })
        
        return {"booking_id": booking_id, "message": "Booking created successfully"}
    
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create booking: {str(e)}")

@app.get("/bookings/")
async def get_all_bookings():
    return {"bookings": list(bookings_db.values())}

@app.get("/bookings/{client_id}")
async def get_client_bookings(client_id: str):
    client_bookings = [b for b in bookings_db.values() if b["client_id"] == client_id]
    return {"bookings": client_bookings}

# Run the service
if __name__ == "__main__":
    uvicorn.run("booking_service:app", host="0.0.0.0", port=8000, reload=True)






#client_service.py
import json
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from kafka import KafkaProducer
import hashlib
import secrets

# Kafka constants
KAFKA_BROKER = "localhost:9092"
TOPIC_CLIENT_LOGGED_IN = "client-logged-in"

# Define FastAPI app
app = FastAPI()

# Configure Kafka producer
producer = KafkaProducer(
    bootstrap_servers=[KAFKA_BROKER],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Database simulation for clients
clients_db = {}
client_id_counter = 1000  # Start client IDs from 1000

# Models
class ClientRegister(BaseModel):
    username: str
    password: str
    name: str
    email: str
    phone: str

class ClientLogin(BaseModel):
    username: str
    password: str

# Helper function to hash passwords
def hash_password(password, salt=None):
    if salt is None:
        salt = secrets.token_hex(16)
    
    pwdhash = hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        100000
    ).hex()
    
    return f"{salt}${pwdhash}"

def verify_password(stored_password, provided_password):
    salt, stored_hash = stored_password.split('$')
    return stored_password == hash_password(provided_password, salt)

# Client endpoints
@app.post("/register/")
async def register_client(client: ClientRegister):
    global client_id_counter
    
    # Check if username already exists
    for existing_client in clients_db.values():
        if existing_client["username"] == client.username:
            raise HTTPException(status_code=400, detail="Username already exists")
    
    # Generate client ID
    client_id = f"C{client_id_counter:04d}"
    client_id_counter += 1
    
    # Hash password
    hashed_password = hash_password(client.password)
    
    # Create client entry
    client_data = {
        "client_id": client_id,
        "username": client.username,
        "password_hash": hashed_password,
        "name": client.name,
        "email": client.email,
        "phone": client.phone,
        "registered_at": datetime.now().isoformat()
    }
    
    # Save to local DB
    clients_db[client_id] = client_data
    
    # Send event for client registration
    producer.send('client-logged-in', {
        "event_type": "client_registered",
        "data": {
            "client_id": client_id,
            "username": client.username,
            "name": client.name,
            "timestamp": datetime.now().isoformat()
        }
    })
    
    # Return success with client ID
    return {"client_id": client_id, "message": "Registration successful"}

@app.post("/login/")
async def login_client(login: ClientLogin):
    # Find client by username
    client = None
    client_id = None
    
    for c_id, c_data in clients_db.items():
        if c_data["username"] == login.username:
            client = c_data
            client_id = c_id
            break
    
    if not client:
        raise HTTPException(status_code=401, detail="Invalid username or password")
    
    # Verify password
    if not verify_password(client["password_hash"], login.password):
        raise HTTPException(status_code=401, detail="Invalid username or password")
    
    # Send login event
    producer.send('client-logged-in', {
        "event_type": "client_logged_in",
        "data": {
            "client_id": client_id,
            "username": client["username"],
            "name": client["name"],
            "timestamp": datetime.now().isoformat()
        }
    })
    
    # Return client data (without password)
    client_info = {k: v for k, v in client.items() if k != "password_hash"}
    return {"client_id": client_id, "client": client_info, "message": "Login successful"}

@app.get("/client/{client_id}")
async def get_client(client_id: str):
    if client_id not in clients_db:
        raise HTTPException(status_code=404, detail="Client not found")
    
    # Return client data (without password)
    client_info = {k: v for k, v in clients_db[client_id].items() if k != "password_hash"}
    return client_info

@app.get("/clients/")
async def get_all_clients():
    # Return all clients (without passwords)
    clients = [{k: v for k, v in client.items() if k != "password_hash"} 
               for client in clients_db.values()]
    
    return {"clients": clients}

# Run the service
if __name__ == "__main__":
    uvicorn.run("client_service:app", host="0.0.0.0", port=8001, reload=True)


#feedback_service.py
import json
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from datetime import datetime
from kafka import KafkaProducer

# Kafka constants
KAFKA_BROKER = "localhost:9092"
TOPIC_FEEDBACK_SUBMITTED = "feedback-submitted"

# Define FastAPI app
app = FastAPI()

# Configure Kafka producer
producer = KafkaProducer(
    bootstrap_servers=[KAFKA_BROKER],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

# Database simulation for feedback
feedback_db = {}

# Models
class FeedbackRequest(BaseModel):
    client_id: str
    barber_id: str
    service_id: str
    rating: int
    comment: str = None

# Feedback endpoints
@app.post("/feedback/")
async def submit_feedback(request: FeedbackRequest):
    try:
        # Validate rating
        if request.rating < 1 or request.rating > 5:
            raise HTTPException(status_code=400, detail="Rating must be between 1 and 5")
        
        # Generate feedback ID
        feedback_id = f"F{len(feedback_db) + 1:03d}"
        
        # Create feedback entry
        timestamp = datetime.now().isoformat()
        feedback = {
            "feedback_id": feedback_id,
            "client_id": request.client_id,
            "barber_id": request.barber_id,
            "service_id": request.service_id,
            "rating": request.rating,
            "comment": request.comment,
            "timestamp": timestamp
        }
        
        # Save to local DB
        feedback_db[feedback_id] = feedback
        
        # Send message to feedback-submitted topic
        producer.send('feedback-submitted', {
            "event_type": "feedback_submitted",
            "data": feedback
        })
        
        return {"feedback_id": feedback_id, "message": "Feedback submitted successfully"}
    
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to submit feedback: {str(e)}")

@app.get("/feedback/")
async def get_all_feedback():
    return {"feedback": list(feedback_db.values())}

@app.get("/feedback/client/{client_id}")
async def get_client_feedback(client_id: str):
    client_feedback = [f for f in feedback_db.values() if f["client_id"] == client_id]
    return {"feedback": client_feedback}

@app.get("/feedback/barber/{barber_id}")
async def get_barber_feedback(barber_id: str):
    barber_feedback = [f for f in feedback_db.values() if f["barber_id"] == barber_id]
    
    # Calculate average rating
    if barber_feedback:
        avg_rating = sum(f["rating"] for f in barber_feedback) / len(barber_feedback)
    else:
        avg_rating = 0
    
    return {
        "barber_id": barber_id,
        "feedback_count": len(barber_feedback),
        "average_rating": avg_rating,
        "feedback": barber_feedback
    }

# Run the service
if __name__ == "__main__":
    uvicorn.run("feedback_service:app", host="0.0.0.0", port=8002, reload=True)


#notification_service.py
import json
from kafka import KafkaConsumer
import threading
import time
from datetime import datetime

# Kafka constants
KAFKA_BROKER = "localhost:9092"
TOPIC_QUEUE_UPDATED = "queue-updated"
TOPIC_FEEDBACK_SUBMITTED = "feedback-submitted"
TOPIC_CLIENT_LOGGED_IN = "client-logged-in"

# Store notifications by client_id
notifications_by_client = {}
admin_notifications = []

# Configure Kafka consumer
consumer = KafkaConsumer(
    TOPIC_QUEUE_UPDATED,
    TOPIC_FEEDBACK_SUBMITTED,
    TOPIC_CLIENT_LOGGED_IN,
    bootstrap_servers=[KAFKA_BROKER],
    auto_offset_reset='earliest',
    enable_auto_commit=True,
    group_id='notification-group',
    value_deserializer=lambda x: json.loads(x.decode('utf-8'))
)

def add_notification(client_id, message, notification_type, data=None):
    """Add a notification for a specific client"""
    if client_id not in notifications_by_client:
        notifications_by_client[client_id] = []
    
    notification = {
        "client_id": client_id,
        "message": message,
        "type": notification_type,
        "timestamp": datetime.now().isoformat(),
        "read": False,
        "data": data
    }
    
    notifications_by_client[client_id].append(notification)
    
    # Also add to admin notifications
    admin_notification = notification.copy()
    admin_notification["admin_read"] = False
    admin_notifications.append(admin_notification)
    
    print(f"Notification added for client {client_id}: {message}")
    return notification

def handle_queue_update(data):
    """Handle queue status update notifications"""
    client_id = data["client_id"]
    status = data["status"]
    queue_id = data["queue_id"]
    
    if status == "waiting":
        position = data.get("position", "unknown")
        wait_time = data.get("estimated_wait", "unknown")
        message = f"You are in queue (position {position}). Estimated wait: {wait_time} minutes."
        add_notification(client_id, message, "queue_update", data)
    elif status == "processing":
        message = f"It's your turn now! Please proceed to your barber."
        add_notification(client_id, message, "queue_update", data)
    elif status == "completed":
        message = f"Your haircut is completed. Thank you for visiting!"
        add_notification(client_id, message, "queue_update", data)
        # Also send a request to give feedback
        add_notification(client_id, "Please share your feedback about your experience", "feedback_request", data)

def handle_feedback_submitted(data):
    """Handle feedback submission notifications"""
    client_id = data["client_id"]
    barber_id = data.get("barber_id", "unknown")
    rating = data.get("rating", "N/A")
    
    message = f"Thank you for your feedback! We value your opinion."
    add_notification(client_id, message, "feedback_confirmation", data)
    
    # Notification for admin
    admin_message = f"New feedback received from client {client_id} for barber {barber_id}. Rating: {rating}/5"
    add_notification("admin", admin_message, "new_feedback", data)

def handle_client_login(data):
    """Handle client login event"""
    client_id = data["client_id"]
    username = data.get("username", "a user")
    
    message = f"Welcome back, {username}!"
    add_notification(client_id, message, "login_welcome", data)
    
    # Notification for admin
    admin_message = f"Client {client_id} ({username}) has logged in"
    add_notification("admin", admin_message, "client_login", data)

def main():
    print("Notification service started. Listening for messages...")
    
    # Main loop to process messages
    for message in consumer:
        data = message.value
        event_type = data.get("event_type")
        payload = data.get("data")
        
        if event_type == "queue_status_changed":
            handle_queue_update(payload)
        elif event_type == "feedback_submitted":
            handle_feedback_submitted(payload)
        elif event_type == "client_logged_in":
            handle_client_login(payload)
        else:
            print(f"Unknown event type: {event_type}")

# API endpoints (using simple HTTP server for demo)
from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.parse

class NotificationHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_path = urllib.parse.urlparse(self.path)
        path = parsed_path.path
        
        if path == "/notifications":
            # Get query parameters
            query = urllib.parse.parse_qs(parsed_path.query)
            client_id = query.get('client_id', [''])[0]
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            if client_id:
                if client_id == "admin":
                    response = {"notifications": admin_notifications}
                else:
                    # Return notifications for specific client
                    client_notifications = notifications_by_client.get(client_id, [])
                    response = {"notifications": client_notifications}
            else:
                # Return all notifications
                response = {"notifications": admin_notifications}
                
            self.wfile.write(json.dumps(response).encode())
            return
        
        # Default response for unknown paths
        self.send_response(404)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps({"error": "Not found"}).encode())

def start_http_server():
    server_address = ('', 8003)
    httpd = HTTPServer(server_address, NotificationHandler)
    print(f"Starting notification HTTP server on port 8003...")
    httpd.serve_forever()

if __name__ == "__main__":
    # Start HTTP server in a separate thread
    server_thread = threading.Thread(target=start_http_server, daemon=True)
    server_thread.start()
    
    # Start Kafka consumer in main thread
    main()

#queue_service.py
import json
from kafka import KafkaConsumer, KafkaProducer
import threading
import time
from datetime import datetime

# Queue management data
active_queue = {}
processed_queue = {}

# Configure Kafka consumer
consumer = KafkaConsumer(
    'booking-created',
    bootstrap_servers=['localhost:9092'],
    auto_offset_reset='earliest',
    enable_auto_commit=True,
    group_id='queue-group',
    value_deserializer=lambda x: json.loads(x.decode('utf-8'))
)

# Configure Kafka producer
producer = KafkaProducer(
    bootstrap_servers=['localhost:9092'],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

def handle_queue_update(queue_entry):
    """Handle a queue update by updating the queue status and notifying clients"""
    queue_id = queue_entry["queue_id"]
    active_queue[queue_id] = queue_entry
    
    # Send notification about updated queue status
    producer.send('queue-updated', {
        "event_type": "queue_status_changed",
        "data": {
            "queue_id": queue_id,
            "client_id": queue_entry["client_id"],
            "status": queue_entry["status"],
            "position": get_queue_position(queue_id),
            "estimated_wait": get_estimated_wait(queue_id),
            "timestamp": datetime.now().isoformat()
        }
    })
    
    print(f"Queue updated: {queue_id}")

def handle_booking_created(booking):
    """Handle a new booking by adding it to the queue system"""
    # For bookings that are for future dates, we don't add them to active queue
    if "booking_date" in booking and "booking_time" in booking:
        # This is a scheduled booking, not a queue entry
        print(f"Received scheduled booking: {booking['booking_id']}")
        return
    
    # Otherwise process as a queue entry
    handle_queue_update(booking)

def get_queue_position(queue_id):
    """Get position in queue (starting from 1)"""
    sorted_queue = sorted(
        active_queue.values(),
        key=lambda x: x["timestamp"]
    )
    
    for i, entry in enumerate(sorted_queue):
        if entry["queue_id"] == queue_id:
            return i + 1
    
    return None  # Not found in queue

def get_estimated_wait(queue_id):
    """Estimate wait time based on position (5 mins per person)"""
    position = get_queue_position(queue_id)
    if position is None:
        return None
    
    # Each client takes about 5 minutes
    return position * 5  # minutes

def process_queue_periodically():
    """Simulate queue processing - every 30 seconds, move the first client forward"""
    while True:
        time.sleep(30)  # Process every 30 seconds
        
        # Sort queue by timestamp
        sorted_queue = sorted(
            active_queue.values(),
            key=lambda x: x["timestamp"]
        )
        
        if not sorted_queue:
            continue
        
        # Get the first waiting client
        waiting_clients = [q for q in sorted_queue if q["status"] == "waiting"]
        if not waiting_clients:
            continue
            
        next_client = waiting_clients[0]
        queue_id = next_client["queue_id"]
        
        # Update status
        active_queue[queue_id]["status"] = "processing"
        
        # Notify about the update
        producer.send('queue-updated', {
            "event_type": "queue_status_changed",
            "data": {
                "queue_id": queue_id,
                "client_id": next_client["client_id"],
                "status": "processing",
                "timestamp": datetime.now().isoformat()
            }
        })
        
        print(f"Processing client: {queue_id}")
        
        # Simulate service time (in real system, barber would mark as completed)
        time.sleep(10)  # For demo, use shorter time
        
        # Mark as completed
        active_queue[queue_id]["status"] = "completed"
        active_queue[queue_id]["completed_at"] = datetime.now().isoformat()
        
        # Move to processed queue
        processed_queue[queue_id] = active_queue[queue_id]
        del active_queue[queue_id]
        
        # Notify about completion
        producer.send('queue-updated', {
            "event_type": "queue_status_changed",
            "data": {
                "queue_id": queue_id,
                "client_id": next_client["client_id"],
                "status": "completed",
                "timestamp": datetime.now().isoformat()
            }
        })
        
        print(f"Completed client: {queue_id}")
        
        # Recalculate and notify all waiting clients about their new positions
        for entry in active_queue.values():
            if entry["status"] == "waiting":
                producer.send('queue-updated', {
                    "event_type": "queue_status_changed",
                    "data": {
                        "queue_id": entry["queue_id"],
                        "client_id": entry["client_id"],
                        "status": entry["status"],
                        "position": get_queue_position(entry["queue_id"]),
                        "estimated_wait": get_estimated_wait(entry["queue_id"]),
                        "timestamp": datetime.now().isoformat()
                    }
                })

def main():
    # Start queue processing in a separate thread
    processing_thread = threading.Thread(target=process_queue_periodically, daemon=True)
    processing_thread.start()
    
    print("Queue service started. Listening for messages...")
    
    # Main loop to process messages
    for message in consumer:
        data = message.value
        event_type = data.get("event_type")
        payload = data.get("data")
        
        if event_type == "queue_created":
            handle_queue_update(payload)
        elif event_type == "booking_created":
            handle_booking_created(payload)
        else:
            print(f"Unknown event type: {event_type}")

if __name__ == "__main__":
    main()



#client_app.py
import tkinter as tk
from tkinter import ttk
import customtkinter as ctk
from datetime import datetime
import time
import requests
import threading
from kafka import KafkaProducer, KafkaConsumer
import json

producer = KafkaProducer(
    bootstrap_servers=['localhost:9092'],
    value_serializer=lambda v: json.dumps(v).encode('utf-8')
)

consumer = KafkaConsumer(
    'queue-updated',
    bootstrap_servers=['localhost:9092'],
    value_deserializer=lambda m: json.loads(m.decode('utf-8')),
    group_id='client-notification-group'
)
username_login_entry = None
password_login_entry = None

username_register_entry = None
password_register_entry = None
name_register_entry = None
# Initialize the app
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("blue")

app = ctk.CTk()
app.geometry("700x700")
app.title("‚úÇÔ∏è Simple Barber Shop App")

# Global variables
current_user = None
current_frame = None
frames = {}

# Sample data (to replace API calls)
sample_barbers = [
    {"barber_id": "B001", "name": "John Smith"},
    {"barber_id": "B002", "name": "Mike Johnson"},
    {"barber_id": "B003", "name": "Sarah Williams"}
]

sample_services = [
    {"id": "S001", "name": "Classic Haircut", "price": 25},
    {"id": "S002", "name": "Beard Trim", "price": 15},
    {"id": "S004", "name": "Hair Coloring", "price": 50}
]

sample_appointments = []
sample_queue = []
sample_users = [{"username": "test", "password": "test", "name": "Test User", "id": "U001"}]
sample_notifications = [
    {"id": 1, "user_id": "U001", "title": "Welcome!", "message": "Welcome to our Barber Shop App!", "date": "2025-04-27", "read": False},
    {"id": 2, "user_id": "U001", "title": "Special Discount", "message": "Get 20% off on your next haircut!", "date": "2025-04-27", "read": False}
]

def listen_to_queue_updates():
    for message in consumer:
        event = message.value
        if event["event_type"] == "queue_status_changed":
            client_id = event["data"]["client_id"]
            queue_id = event["data"]["queue_id"]
            status = event["data"]["status"]
            position = event["data"]["position"]
            estimated_wait = event["data"]["estimated_wait"]

            # Create new notification
            new_notification = {
                "id": str(len(sample_notifications) + 1),
                "user_id": client_id,
                "title": "Queue Status Update",
                "message": f"Your queue status is '{status.upper()}'. Position: {position}, Estimated wait: {estimated_wait} mins.",
                "date": datetime.now().strftime("%Y-%m-%d"),
                "read": False
            }
            sample_notifications.append(new_notification)

            # Refresh if current user matches
            if current_user and (current_user.get("client_id") == client_id or current_user.get("id") == client_id):
                refresh_notifications()

# Start the listener in a background thread
listener_thread = threading.Thread(target=listen_to_queue_updates, daemon=True)
listener_thread.start()
# Function to switch between frames
def show_frame(frame_name):
    global current_frame
    if current_frame:
        frames[current_frame].pack_forget()
    
    frames[frame_name].pack(fill="both", expand=True)
    current_frame = frame_name
    
    # Special handling for some frames
    if frame_name == "dashboard" and current_user:
        welcome_label.configure(text=f"Welcome, {current_user['name']}!")
    elif frame_name == "notifications" and current_user:
        refresh_notifications()

# Create all frames
def create_frames():
    frame_list = ["login", "register", "dashboard", "booking", "queue", "appointments", "notifications"]
    
    for name in frame_list:
        frames[name] = ctk.CTkFrame(app)
        frames[name].pack_forget()
    
    setup_login_frame()
    setup_register_frame()
    setup_dashboard_frame()
    setup_booking_frame()
    setup_queue_frame()
    setup_appointments_frame()
    setup_notifications_frame()

# Login frame
def setup_login_frame():
    global username_login_entry, password_login_entry

    frame = frames["login"]

    # Title
    title = ctk.CTkLabel(frame, text="‚úÇÔ∏è Barber Shop Login", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(50, 20))

    # Username
    username_label = ctk.CTkLabel(frame, text="Username:")
    username_label.pack(pady=(10, 5))
    username_login_entry = ctk.CTkEntry(frame, width=300)
    username_login_entry.pack(pady=(0, 10))

    # Password
    password_label = ctk.CTkLabel(frame, text="Password:")
    password_label.pack(pady=(10, 5))
    password_login_entry = ctk.CTkEntry(frame, width=300, show="*")
    password_login_entry.pack(pady=(0, 20))

    # Status message
    global login_status
    login_status = ctk.CTkLabel(frame, text="", text_color="red")
    login_status.pack(pady=(0, 10))

    # Login button
    def login():
        username = username_login_entry.get()
        password = password_login_entry.get()

        login_status.configure(text="Logging in...", text_color="white")

        try:
            response = requests.post(
                "http://localhost:8001/login/",
                json={"username": username, "password": password}
            )
            if response.status_code == 200:
                data = response.json()
                global current_user
                current_user = data["client"]
                current_user["client_id"] = data["client_id"]
                login_status.configure(text="Login successful!", text_color="green")
                show_frame("dashboard")
            else:
                error_detail = response.json().get("detail", "Invalid username or password")
                login_status.configure(text=f"Error: {error_detail}", text_color="red")
        except Exception as e:
            login_status.configure(text=f"Server error: {str(e)}", text_color="red")

    login_button = ctk.CTkButton(frame, text="Login", command=login, width=300)
    login_button.pack(pady=(10, 10))

    # Register link
    def go_to_register():
        show_frame("register")

    register_link = ctk.CTkButton(frame, text="Don't have an account? Register", 
                                  command=go_to_register, fg_color="transparent", hover=False)
    register_link.pack(pady=(10, 0))

    
    

# Register frame
def setup_register_frame():
    global username_register_entry, password_register_entry, name_register_entry

    frame = frames["register"]

    title = ctk.CTkLabel(frame, text="‚úÇÔ∏è Create an Account", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(30, 20))

    username_label = ctk.CTkLabel(frame, text="Username:")
    username_label.pack(pady=(10, 5))
    username_register_entry = ctk.CTkEntry(frame, width=300)
    username_register_entry.pack(pady=(0, 5))

    password_label = ctk.CTkLabel(frame, text="Password:")
    password_label.pack(pady=(5, 5))
    password_register_entry = ctk.CTkEntry(frame, width=300, show="*")
    password_register_entry.pack(pady=(0, 5))

    name_label = ctk.CTkLabel(frame, text="Full Name:")
    name_label.pack(pady=(5, 5))
    name_register_entry = ctk.CTkEntry(frame, width=300)
    name_register_entry.pack(pady=(0, 5))

    global register_status
    register_status = ctk.CTkLabel(frame, text="", text_color="red")
    register_status.pack(pady=(10, 10))

    def register():
        username = username_register_entry.get()
        password = password_register_entry.get()
        name = name_register_entry.get()

        if not username or not password or not name:
            register_status.configure(text="Please fill all fields", text_color="red")
            return

        try:
            response = requests.post(
                "http://localhost:8001/register/",
                json={
                    "username": username,
                    "password": password,
                    "name": name,
                    "email": f"{username}@example.com",
                    "phone": "09123456789"
                }
            )
            if response.status_code == 200:
                data = response.json()
                register_status.configure(
                    text=f"Registration successful! Logging you in...", 
                    text_color="green"
                )

                # Auto-login after registration
                try:
                    login_response = requests.post(
                        "http://localhost:8001/login/",
                        json={
                            "username": username,
                            "password": password
                        }
                    )
                    if login_response.status_code == 200:
                        login_data = login_response.json()
                        global current_user
                        current_user = login_data["client"]
                        current_user["client_id"] = login_data["client_id"]
                        show_frame("dashboard")  # Go to dashboard directly
                    else:
                        register_status.configure(
                            text="Registration succeeded but auto-login failed. Please login manually.",
                            text_color="orange"
                        )
                except Exception as e:
                    register_status.configure(
                        text=f"Auto-login error: {str(e)}", 
                        text_color="red"
                    )

            else:
                register_status.configure(
                    text=f"Error: {response.json().get('detail', 'Unknown')}", 
                    text_color="red"
                )

        except Exception as e:
            register_status.configure(text=f"Server error: {str(e)}", text_color="red")


    register_button = ctk.CTkButton(frame, text="Register", command=register, width=300)
    register_button.pack(pady=(10, 10))

    def go_to_login():
        show_frame("login")

    login_link = ctk.CTkButton(frame, text="Already have an account? Login", 
                               command=go_to_login, fg_color="transparent", hover=False)
    login_link.pack(pady=(10, 0))




# Dashboard frame
def setup_dashboard_frame():
    frame = frames["dashboard"]
    
    # Welcome message
    global welcome_label
    welcome_label = ctk.CTkLabel(frame, text="Welcome!", font=ctk.CTkFont(size=24, weight="bold"))
    welcome_label.pack(pady=(50, 30))
    
    # Button frame
    button_frame = ctk.CTkFrame(frame, fg_color="transparent")
    button_frame.pack(pady=20)
    
    # Booking button
    def go_to_booking():
        show_frame("booking")
    
    booking_button = ctk.CTkButton(button_frame, text="Book Appointment", command=go_to_booking, width=200)
    booking_button.grid(row=0, column=0, padx=10, pady=10)
    
    # Queue button
    def go_to_queue():
        show_frame("queue")
    
    queue_button = ctk.CTkButton(button_frame, text="Join Queue", command=go_to_queue, width=200)
    queue_button.grid(row=0, column=1, padx=10, pady=10)
    
    # View appointments button
    def go_to_appointments():
        show_frame("appointments")
    
    appointments_button = ctk.CTkButton(button_frame, text="My Appointments", command=go_to_appointments, width=200)
    appointments_button.grid(row=1, column=0, padx=10, pady=10)
    
    # Notifications button
    def go_to_notifications():
        show_frame("notifications")
    
    notifications_button = ctk.CTkButton(button_frame, text="Notifications", command=go_to_notifications, width=200)
    notifications_button.grid(row=1, column=1, padx=10, pady=10)
    
    # Logout button
    def logout():
        global current_user
        current_user = None
        show_frame("login")
    
    logout_button = ctk.CTkButton(frame, text="Logout", command=logout, 
                                 fg_color="red", hover_color="darkred", width=200)
    logout_button.pack(pady=(30, 0))

# Booking frame
def setup_booking_frame():
    frame = frames["booking"]
    
    # Title
    title = ctk.CTkLabel(frame, text="Book an Appointment", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(30, 20))
    
    # Barber selection
    barber_label = ctk.CTkLabel(frame, text="Select Barber:")
    barber_label.pack(pady=(10, 5))
    barber_var = tk.StringVar()
    barber_names = [barber["name"] for barber in sample_barbers]
    barber_dropdown = ctk.CTkOptionMenu(frame, variable=barber_var, values=barber_names, width=300)
    barber_dropdown.pack(pady=(0, 10))
    if barber_names:
        barber_dropdown.set(barber_names[0])
    
    # Service selection
    service_label = ctk.CTkLabel(frame, text="Select Service:")
    service_label.pack(pady=(10, 5))
    service_var = tk.StringVar()
    service_names = [f"{service['name']} (${service['price']})" for service in sample_services]
    service_dropdown = ctk.CTkOptionMenu(frame, variable=service_var, values=service_names, width=300)
    service_dropdown.pack(pady=(0, 10))
    if service_names:
        service_dropdown.set(service_names[0])
    
    # Date selection
    date_label = ctk.CTkLabel(frame, text="Date (YYYY-MM-DD):")
    date_label.pack(pady=(10, 5))
    date_entry = ctk.CTkEntry(frame, width=300)
    date_entry.pack(pady=(0, 10))
    date_entry.insert(0, datetime.now().strftime("%Y-%m-%d"))
    
    # Time selection
    time_label = ctk.CTkLabel(frame, text="Time (HH:MM):")
    time_label.pack(pady=(10, 5))
    time_entry = ctk.CTkEntry(frame, width=300)
    time_entry.pack(pady=(0, 10))
    time_entry.insert(0, "09:00")
    
    # Status message
    status = ctk.CTkLabel(frame, text="", text_color="green")
    status.pack(pady=(5, 10))
    
    # Book button
    def book_appointment():
        if not current_user:
            status.configure(text="Please login first", text_color="red")
            return

        date = date_entry.get()
        time_val = time_entry.get()
        barber_name = barber_var.get()
        service_name = service_var.get().split(" (")[0]  # Extract service name only

        # Find barber and service by name
        barber = next((b for b in sample_barbers if b["name"] == barber_name), None)
        service = next((s for s in sample_services if s["name"] == service_name), None)

        if not barber or not service:
            status.configure(text="Invalid barber or service selection", text_color="red")
            return

        user_id = current_user.get("id") or current_user.get("client_id")

        try:
            # üöÄ Now send correct barber_id (string!) and service_type (string!)
            payload = {
                "client_id": user_id,
                "barber_id": barber["barber_id"],    # <-- string like "B001"
                "service_type": service["id"],        # <-- string like "S001"
                "booking_date": date,
                "booking_time": time_val
            }
            response = requests.post("http://localhost:8000/booking/", json=payload)

            if response.status_code == 200:
                data = response.json()
                appointment_id = data.get("booking_id", "Unknown")

                # Kafka notification (optional)
                producer.send('notification-updated', {
                    "event_type": "appointment_booked",
                    "data": {
                        "client_id": user_id,
                        "appointment_id": appointment_id,
                        "barber_name": barber_name,
                        "service_name": service_name,
                        "datetime": f"{date} {time_val}"
                    }
                })
                producer.flush()

                status.configure(text=f"Appointment booked! ID: {appointment_id}", text_color="green")
                print(f"[INFO] Appointment booked - ID: {appointment_id}, User: {current_user['name']}, Barber: {barber_name}, Service: {service_name}, DateTime: {date} {time_val}")
            
            else:
                status.configure(text=f"Booking failed: {response.json().get('detail', 'Unknown error')}", text_color="red")
        
        except Exception as e:
            status.configure(text=f"Server error: {e}", text_color="red")


    book_button = ctk.CTkButton(frame, text="Book Appointment", command=book_appointment, width=300)
    book_button.pack(pady=(0, 10))
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, fg_color="transparent")
    back_button.pack(pady=(10, 0))

# Queue frame
def setup_queue_frame():
    frame = frames["queue"]

    # Title
    title = ctk.CTkLabel(frame, text="Join the Queue", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(30, 20))

    # Current queue status
    queue_status_label = ctk.CTkLabel(frame, text="Current Queue Status:", font=ctk.CTkFont(size=16))
    queue_status_label.pack(pady=(10, 5))

    queue_count = ctk.CTkLabel(frame, text=f"People in queue: {len(sample_queue)}")
    queue_count.pack(pady=(0, 20))

    # Barber selection
    barber_label = ctk.CTkLabel(frame, text="Select Barber (Optional):")
    barber_label.pack(pady=(10, 5))
    barber_var = tk.StringVar(value="Any Available")
    barber_names = ["Any Available"] + [barber["name"] for barber in sample_barbers]
    barber_dropdown = ctk.CTkOptionMenu(frame, variable=barber_var, values=barber_names, width=300)
    barber_dropdown.pack(pady=(0, 10))

    # Service selection
    service_label = ctk.CTkLabel(frame, text="Select Service:")
    service_label.pack(pady=(10, 5))
    service_var = tk.StringVar()
    service_names = [service["name"] for service in sample_services]
    service_dropdown = ctk.CTkOptionMenu(frame, variable=service_var, values=service_names, width=300)
    service_dropdown.pack(pady=(0, 10))
    if service_names:
        service_dropdown.set(service_names[0])

    # Status message
    status = ctk.CTkLabel(frame, text="", text_color="green")
    status.pack(pady=(10, 10))

    # Join queue button
    def join_queue():
        if not current_user:
            status.configure(text="Please login first", text_color="red")
            return

        barber_name = barber_var.get()
        service_name = service_var.get()

        # Check if user is already in queue
        if any(q["user_id"] == current_user["client_id"] for q in sample_queue):
            status.configure(text="You are already in the queue", text_color="red")
            return

        # Add to queue (local memory)
        queue_id = f"Q{len(sample_queue) + 1:03d}"
        queue_entry = {
            "id": queue_id,
            "user_id": current_user["client_id"],
            "user_name": current_user["name"],
            "barber_preference": None if barber_name == "Any Available" else barber_name,
            "service": service_name,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "status": "Waiting"
        }

        sample_queue.append(queue_entry)

        # Send Kafka Event (very important)
        producer.send('queue-updated', {
            "event_type": "queue_status_changed",
            "data": {
                "client_id": current_user["client_id"],
                "queue_id": queue_id,
                "status": "waiting",
                "position": len(sample_queue),
                "estimated_wait": len(sample_queue) * 30
            }
        })
        producer.flush()

        queue_count.configure(text=f"People in queue: {len(sample_queue)}")
        status.configure(text=f"Added to queue! Your position: {len(sample_queue)}", text_color="green")


    queue_button = ctk.CTkButton(frame, text="Join Queue", command=join_queue, width=300)
    queue_button.pack(pady=(0, 10))

    # Current queue display
    queue_frame = ctk.CTkFrame(frame)
    queue_frame.pack(pady=10, fill="both", expand=True, padx=20)

    queue_list = ctk.CTkTextbox(queue_frame, height=100)
    queue_list.pack(fill="both", expand=True, padx=5, pady=5)

    def update_queue_display():
        queue_list.delete("1.0", tk.END)
        if not sample_queue:
            queue_list.insert("1.0", "Queue is currently empty")
            return

        for i, q in enumerate(sample_queue):
            queue_list.insert(tk.END, f"{i+1}. {q['user_name']} - {q['user_id']}\n")

    update_queue_display()

    # Refresh button
    refresh_button = ctk.CTkButton(frame, text="Refresh Queue", command=update_queue_display, width=200)
    refresh_button.pack(pady=(10, 0))

    # Back button
    def go_back():
        show_frame("dashboard")

    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, fg_color="transparent")
    back_button.pack(pady=(10, 20))



# Appointments frame
def setup_appointments_frame():
    frame = frames["appointments"]
    
    # Title
    title = ctk.CTkLabel(frame, text="My Appointments", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(30, 20))
    
    # Create appointment list
    table_frame = ttk.Frame(frame)
    table_frame.pack(pady=10, fill="both", expand=True, padx=20)
    
    columns = ("ID", "Barber", "Service", "Date & Time", "Status")
    appointments_table = ttk.Treeview(table_frame, columns=columns, show="headings")
    
    for col in columns:
        appointments_table.heading(col, text=col)
        appointments_table.column(col, anchor="center")
    
    appointments_table.pack(fill="both", expand=True)
    
    # Function to refresh appointments
    def refresh_appointments():
        for row in appointments_table.get_children():
            appointments_table.delete(row)
        
        if not current_user:
            return
        
        # Get user_id safely (id or client_id)
        user_id = current_user.get("id") or current_user.get("client_id")
        
        user_appointments = [a for a in sample_appointments if a["user_id"] == user_id]
        
        if not user_appointments:
            appointments_table.insert("", "end", values=("No appointments", "", "", "", ""))
            return
        
        for appointment in user_appointments:
            appointments_table.insert("", "end", values=(
                appointment["id"],
                appointment["barber_name"],
                appointment["service_name"],
                appointment["datetime"],
                appointment["status"]
            ))
    
    # Cancel button
    def cancel_appointment():
        selected = appointments_table.selection()
        if not selected:
            return

        item = appointments_table.item(selected[0])
        appointment_id = item["values"][0]

        if appointment_id == "No appointments":
            return

        # Find and remove appointment
        for i, appointment in enumerate(sample_appointments):
            if appointment["id"] == appointment_id:
                # Add a notification about cancellation
                notification_id = len(sample_notifications) + 1

                # Get user_id safely (id or client_id)
                user_id = current_user.get("id") or current_user.get("client_id")

                notification = {
                    "id": notification_id,
                    "user_id": user_id,
                    "title": "Appointment Cancelled",
                    "message": f"Your appointment ({appointment_id}) with {appointment['barber_name']} has been cancelled.",
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "read": False
                }
                sample_notifications.append(notification)

                # REMOVE the appointment
                del sample_appointments[i]
                break

        refresh_appointments()
    


    
    cancel_button = ctk.CTkButton(frame, text="Cancel Selected Appointment", 
                                  command=cancel_appointment, fg_color="red", 
                                  hover_color="darkred", width=250)
    cancel_button.pack(pady=(10, 0))
    
    refresh_button = ctk.CTkButton(frame, text="Refresh", command=refresh_appointments, width=200)
    refresh_button.pack(pady=(10, 0))
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, fg_color="transparent")
    back_button.pack(pady=(10, 20))

    # Initial Load
    refresh_appointments()

# Notifications frame
def setup_notifications_frame():
    frame = frames["notifications"]
    
    # Title
    title = ctk.CTkLabel(frame, text="My Notifications", font=ctk.CTkFont(size=24, weight="bold"))
    title.pack(pady=(30, 20))
    
    # Create notifications list
    table_frame = ttk.Frame(frame)
    table_frame.pack(pady=10, fill="both", expand=True, padx=20)
    
    columns = ("ID", "Title", "Message", "Date", "Status")
    global notifications_table
    notifications_table = ttk.Treeview(table_frame, columns=columns, show="headings")
    
    # Configure column headings and widths
    notifications_table.heading("ID", text="ID")
    notifications_table.column("ID", width=50, anchor="center")
    
    notifications_table.heading("Title", text="Title")
    notifications_table.column("Title", width=100, anchor="w")
    
    notifications_table.heading("Message", text="Message")
    notifications_table.column("Message", width=300, anchor="w")
    
    notifications_table.heading("Date", text="Date")
    notifications_table.column("Date", width=100, anchor="center")
    
    notifications_table.heading("Status", text="Status")
    notifications_table.column("Status", width=80, anchor="center")
    
    notifications_table.pack(fill="both", expand=True)
    
    # Add scrollbar
    scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=notifications_table.yview)
    notifications_table.configure(yscroll=scrollbar.set)
    scrollbar.pack(side="right", fill="y")
    
    # Mark as read button
    def mark_as_read():
        if not current_user:
            return
        
        selected = notifications_table.selection()
        if not selected:
            return
        
        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        for item_id in selected:
            item = notifications_table.item(item_id)
            notification_id = item["values"][0]
            
            # Find and update notification
            for i, notification in enumerate(sample_notifications):
                if notification["id"] == notification_id and notification["user_id"] == user_id:
                    sample_notifications[i]["read"] = True
                    break
        
        refresh_notifications()
    
    buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
    buttons_frame.pack(pady=10)
    
    mark_read_button = ctk.CTkButton(buttons_frame, text="Mark as Read", 
                                     command=mark_as_read, width=200)
    mark_read_button.grid(row=0, column=0, padx=10)
    
    # Mark all as read button
    def mark_all_as_read():
        if not current_user:
            return
        
        # Get user_id safely
        user_id = current_user.get("id") or current_user.get("client_id")
        
        for i, notification in enumerate(sample_notifications):
            if notification["user_id"] == user_id:
                sample_notifications[i]["read"] = True
        
        refresh_notifications()
    
    mark_all_button = ctk.CTkButton(buttons_frame, text="Mark All as Read", 
                                    command=mark_all_as_read, width=200)
    mark_all_button.grid(row=0, column=1, padx=10)
    
    # Back button
    def go_back():
        show_frame("dashboard")
    
    back_button = ctk.CTkButton(frame, text="Back to Dashboard", command=go_back, fg_color="transparent")
    back_button.pack(pady=(10, 20))

    # Initial refresh
    refresh_notifications()

# üî• Updated refresh_notifications()
def refresh_notifications():
    if not current_user or 'notifications_table' not in globals():
        return
        
    # Clear existing items
    for row in notifications_table.get_children():
        notifications_table.delete(row)
    
    # Get user_id safely
    user_id = current_user.get("id") or current_user.get("client_id")
    
    # Get user notifications
    user_notifications = [n for n in sample_notifications if n["user_id"] == user_id]
    
    if not user_notifications:
        notifications_table.insert("", "end", values=("", "No notifications", "", "", ""))
        return
    
    # Sort by unread first, then latest first
    user_notifications.sort(key=lambda x: (x["read"], -int(x["id"])))
    
    for notification in user_notifications:
        status_text = "Read" if notification["read"] else "Unread"
        notifications_table.insert("", "end", values=(
            notification["id"],
            notification["title"],
            notification["message"],
            notification["date"],
            status_text
        ))


# Create all frames and start with login
create_frames()
show_frame("login")

# Start the app
app.mainloop()